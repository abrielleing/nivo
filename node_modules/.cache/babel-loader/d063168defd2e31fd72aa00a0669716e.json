{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar isNumber = _interopDefault(require('lodash/isNumber'));\n\nvar isArray = _interopDefault(require('lodash/isArray'));\n\nvar core = require('@nivo/core');\n\nvar React = require('react');\n\nvar React__default = _interopDefault(React);\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar isFunction = _interopDefault(require('lodash/isFunction'));\n\nvar d3Format = require('d3-format');\n\nvar d3TimeFormat = require('d3-time-format');\n\nvar compose = _interopDefault(require('recompose/compose'));\n\nvar withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));\n\nvar pure = _interopDefault(require('recompose/pure'));\n\nvar setDisplayName = _interopDefault(require('recompose/setDisplayName'));\n\nvar reactMotion = require('react-motion');\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar centerScale = function centerScale(scale) {\n  var bandwidth = scale.bandwidth();\n  if (bandwidth === 0) return scale;\n  var offset = bandwidth / 2;\n\n  if (scale.round()) {\n    offset = Math.round(offset);\n  }\n\n  return function (d) {\n    return scale(d) + offset;\n  };\n};\n\nvar getScaleTicks = function getScaleTicks(scale, tickCount) {\n  if (scale.ticks) return scale.ticks(tickCount);\n  return scale.domain();\n};\n\nvar computeCartesianTicks = function computeCartesianTicks(_ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      ticksPosition = _ref.ticksPosition,\n      _tickValues = _ref.tickValues,\n      tickSize = _ref.tickSize,\n      tickPadding = _ref.tickPadding,\n      tickRotation = _ref.tickRotation,\n      _ref$engine = _ref.engine,\n      engine = _ref$engine === undefined ? 'svg' : _ref$engine;\n  var tickValues = isArray(_tickValues) ? _tickValues : undefined;\n  var tickCount = isNumber(_tickValues) ? _tickValues : undefined;\n  var values = tickValues || getScaleTicks(scale, tickCount);\n  var textProps = core.textPropsByEngine[engine];\n  var position = scale.bandwidth ? centerScale(scale) : scale;\n  var line = {\n    lineX: 0,\n    lineY: 0\n  };\n  var text = {\n    textX: 0,\n    textY: 0\n  };\n  var translate = void 0;\n  var textAlign = textProps.align.center;\n  var textBaseline = textProps.baseline.center;\n\n  if (axis === 'x') {\n    translate = function translate(d) {\n      return {\n        x: position(d),\n        y: 0\n      };\n    };\n\n    line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textBaseline = textProps.baseline.top;\n    } else {\n      textBaseline = textProps.baseline.bottom;\n    }\n\n    if (tickRotation === 0) {\n      textAlign = textProps.align.center;\n    } else if (ticksPosition === 'after' && tickRotation < 0 || ticksPosition === 'before' && tickRotation > 0) {\n      textAlign = textProps.align.right;\n      textBaseline = textProps.baseline.center;\n    } else if (ticksPosition === 'after' && tickRotation > 0 || ticksPosition === 'before' && tickRotation < 0) {\n      textAlign = textProps.align.left;\n      textBaseline = textProps.baseline.center;\n    }\n  } else {\n    translate = function translate(d) {\n      return {\n        x: 0,\n        y: position(d)\n      };\n    };\n\n    line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textAlign = textProps.align.left;\n    } else {\n      textAlign = textProps.align.right;\n    }\n  }\n\n  var ticks = values.map(function (value) {\n    return _extends({\n      key: value,\n      value: value\n    }, translate(value), line, text);\n  });\n  return {\n    ticks: ticks,\n    textAlign: textAlign,\n    textBaseline: textBaseline\n  };\n};\n\nvar AxisTick = function (_PureComponent) {\n  inherits(AxisTick, _PureComponent);\n\n  function AxisTick() {\n    classCallCheck(this, AxisTick);\n    return possibleConstructorReturn(this, _PureComponent.apply(this, arguments));\n  }\n\n  AxisTick.prototype.render = function render() {\n    var _props = this.props,\n        _value = _props.value,\n        x = _props.x,\n        y = _props.y,\n        opacity = _props.opacity,\n        rotate = _props.rotate,\n        format = _props.format,\n        lineX = _props.lineX,\n        lineY = _props.lineY,\n        _onClick = _props.onClick,\n        textX = _props.textX,\n        textY = _props.textY,\n        textBaseline = _props.textBaseline,\n        textAnchor = _props.textAnchor,\n        theme = _props.theme;\n    var value = _value;\n\n    if (format !== undefined) {\n      value = format(value);\n    }\n\n    var gStyle = {\n      opacity: opacity\n    };\n\n    if (_onClick) {\n      gStyle['cursor'] = 'pointer';\n    }\n\n    return React__default.createElement('g', _extends({\n      transform: 'translate(' + x + ',' + y + ')'\n    }, _onClick ? {\n      onClick: function onClick(e) {\n        return _onClick(e, value);\n      }\n    } : {}, {\n      style: gStyle\n    }), React__default.createElement('line', {\n      x1: 0,\n      x2: lineX,\n      y1: 0,\n      y2: lineY,\n      style: theme.axis.ticks.line\n    }), React__default.createElement('text', {\n      alignmentBaseline: textBaseline,\n      textAnchor: textAnchor,\n      transform: 'translate(' + textX + ',' + textY + ') rotate(' + rotate + ')',\n      style: theme.axis.ticks.text\n    }, value));\n  };\n\n  return AxisTick;\n}(React.PureComponent);\n\nAxisTick.propTypes = {\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n  format: PropTypes.func,\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n  lineX: PropTypes.number.isRequired,\n  lineY: PropTypes.number.isRequired,\n  textX: PropTypes.number.isRequired,\n  textY: PropTypes.number.isRequired,\n  textBaseline: PropTypes.string.isRequired,\n  textAnchor: PropTypes.string.isRequired,\n  opacity: PropTypes.number.isRequired,\n  rotate: PropTypes.number.isRequired,\n  onClick: PropTypes.func,\n  theme: PropTypes.shape({\n    axis: core.axisThemePropType.isRequired\n  }).isRequired\n};\nAxisTick.defaultProps = {\n  opacity: 1,\n  rotate: 0\n};\n\nvar willEnter = function willEnter() {\n  return {\n    rotate: 0,\n    opacity: 0,\n    x: 0,\n    y: 0\n  };\n};\n\nvar willLeave = function willLeave(springConfig) {\n  return function (_ref) {\n    var _ref$style = _ref.style,\n        x = _ref$style.x,\n        y = _ref$style.y,\n        rotate = _ref$style.rotate;\n    return {\n      rotate: rotate,\n      opacity: reactMotion.spring(0, springConfig),\n      x: reactMotion.spring(x.val, springConfig),\n      y: reactMotion.spring(y.val, springConfig)\n    };\n  };\n};\n\nvar defaultTickRenderer = function defaultTickRenderer(props) {\n  return React__default.createElement(AxisTick, props);\n};\n\nvar Axis = function (_Component) {\n  inherits(Axis, _Component);\n\n  function Axis() {\n    classCallCheck(this, Axis);\n    return possibleConstructorReturn(this, _Component.apply(this, arguments));\n  }\n\n  Axis.prototype.render = function render() {\n    var _props = this.props,\n        axis = _props.axis,\n        scale = _props.scale,\n        x = _props.x,\n        y = _props.y,\n        length = _props.length,\n        ticksPosition = _props.ticksPosition,\n        tickValues = _props.tickValues,\n        tickSize = _props.tickSize,\n        tickPadding = _props.tickPadding,\n        tickRotation = _props.tickRotation,\n        tickValueFormat = _props.tickValueFormat,\n        renderTick = _props.renderTick,\n        legend = _props.legend,\n        legendPosition = _props.legendPosition,\n        legendOffset = _props.legendOffset,\n        theme = _props.theme,\n        animate = _props.animate,\n        motionStiffness = _props.motionStiffness,\n        motionDamping = _props.motionDamping,\n        onClick = _props.onClick;\n\n    var _computeCartesianTick = computeCartesianTicks({\n      axis: axis,\n      scale: scale,\n      ticksPosition: ticksPosition,\n      tickValues: tickValues,\n      tickSize: tickSize,\n      tickPadding: tickPadding,\n      tickRotation: tickRotation\n    }),\n        ticks = _computeCartesianTick.ticks,\n        textAlign = _computeCartesianTick.textAlign,\n        textBaseline = _computeCartesianTick.textBaseline;\n\n    var legendNode = null;\n\n    if (legend !== undefined) {\n      var legendX = 0;\n      var legendY = 0;\n      var legendRotation = 0;\n      var textAnchor = void 0;\n\n      if (axis === 'y') {\n        legendRotation = -90;\n        legendX = legendOffset;\n\n        if (legendPosition === 'start') {\n          textAnchor = 'start';\n          legendY = length;\n        } else if (legendPosition === 'middle') {\n          textAnchor = 'middle';\n          legendY = length / 2;\n        } else if (legendPosition === 'end') {\n          textAnchor = 'end';\n        }\n      } else {\n        legendY = legendOffset;\n\n        if (legendPosition === 'start') {\n          textAnchor = 'start';\n        } else if (legendPosition === 'middle') {\n          textAnchor = 'middle';\n          legendX = length / 2;\n        } else if (legendPosition === 'end') {\n          textAnchor = 'end';\n          legendX = length;\n        }\n      }\n\n      legendNode = React__default.createElement('text', {\n        transform: 'translate(' + legendX + ', ' + legendY + ') rotate(' + legendRotation + ')',\n        textAnchor: textAnchor,\n        style: _extends({\n          alignmentBaseline: 'middle'\n        }, theme.axis.legend.text)\n      }, legend);\n    }\n\n    if (animate !== true) {\n      return React__default.createElement('g', {\n        transform: 'translate(' + x + ',' + y + ')'\n      }, ticks.map(function (tick) {\n        return renderTick(_extends({\n          format: tickValueFormat,\n          rotate: tickRotation,\n          textBaseline: textBaseline,\n          textAnchor: textAlign,\n          theme: theme\n        }, tick, onClick ? {\n          onClick: onClick\n        } : {}));\n      }), React__default.createElement('line', {\n        style: theme.axis.domain.line,\n        x1: 0,\n        x2: axis === 'x' ? length : 0,\n        y1: 0,\n        y2: axis === 'x' ? 0 : length\n      }), legendNode);\n    }\n\n    var springConfig = {\n      stiffness: motionStiffness,\n      damping: motionDamping\n    };\n    return React__default.createElement(reactMotion.Motion, {\n      style: {\n        x: reactMotion.spring(x, springConfig),\n        y: reactMotion.spring(y, springConfig)\n      }\n    }, function (xy) {\n      return React__default.createElement('g', {\n        transform: 'translate(' + xy.x + ',' + xy.y + ')'\n      }, React__default.createElement(reactMotion.TransitionMotion, {\n        willEnter: willEnter,\n        willLeave: willLeave(springConfig),\n        styles: ticks.map(function (tick) {\n          return {\n            key: '' + tick.key,\n            data: tick,\n            style: {\n              opacity: reactMotion.spring(1, springConfig),\n              x: reactMotion.spring(tick.x, springConfig),\n              y: reactMotion.spring(tick.y, springConfig),\n              rotate: reactMotion.spring(tickRotation, springConfig)\n            }\n          };\n        })\n      }, function (interpolatedStyles) {\n        return React__default.createElement(React.Fragment, null, interpolatedStyles.map(function (_ref2) {\n          var style = _ref2.style,\n              tick = _ref2.data;\n          return renderTick(_extends({\n            format: tickValueFormat,\n            textBaseline: textBaseline,\n            textAnchor: textAlign,\n            theme: theme\n          }, tick, style, onClick ? {\n            onClick: onClick\n          } : {}));\n        }));\n      }), React__default.createElement(reactMotion.Motion, {\n        style: {\n          x2: reactMotion.spring(axis === 'x' ? length : 0, springConfig),\n          y2: reactMotion.spring(axis === 'x' ? 0 : length, springConfig)\n        }\n      }, function (values) {\n        return React__default.createElement('line', _extends({\n          style: theme.axis.domain.line,\n          x1: 0,\n          y1: 0\n        }, values));\n      }), legendNode);\n    });\n  };\n\n  return Axis;\n}(React.Component);\n\nAxis.propTypes = _extends({\n  axis: PropTypes.oneOf(['x', 'y']).isRequired,\n  scale: PropTypes.func.isRequired,\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n  length: PropTypes.number.isRequired,\n  ticksPosition: PropTypes.oneOf(['before', 'after']).isRequired,\n  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),\n  tickSize: PropTypes.number.isRequired,\n  tickPadding: PropTypes.number.isRequired,\n  tickRotation: PropTypes.number.isRequired,\n  tickFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  renderTick: PropTypes.func.isRequired,\n  legend: PropTypes.node,\n  legendPosition: PropTypes.oneOf(['start', 'middle', 'end']).isRequired,\n  legendOffset: PropTypes.number.isRequired,\n  theme: PropTypes.shape({\n    axis: core.axisThemePropType.isRequired\n  }).isRequired\n}, core.motionPropTypes);\nAxis.defaultProps = {\n  x: 0,\n  y: 0,\n  tickSize: 5,\n  tickPadding: 5,\n  tickRotation: 0,\n  renderTick: defaultTickRenderer,\n  legendPosition: 'end',\n  legendOffset: 0\n};\nvar enhance = compose(core.withMotion(), withPropsOnChange(['format', 'scale'], function (_ref3) {\n  var format = _ref3.format,\n      scale = _ref3.scale;\n\n  if (!format || isFunction(format)) {\n    return {\n      format: format\n    };\n  } else if (scale.type === 'time') {\n    var f = d3TimeFormat.timeFormat(format);\n    return {\n      format: function format(d) {\n        return f(new Date(d));\n      }\n    };\n  } else {\n    return {\n      format: d3Format.format(format)\n    };\n  }\n}), pure);\nvar Axis$1 = setDisplayName('Axis')(enhance(Axis));\nvar axisPropTypes = {\n  ticksPosition: PropTypes.oneOf(['before', 'after']),\n  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)]))]),\n  tickSize: PropTypes.number,\n  tickPadding: PropTypes.number,\n  tickRotation: PropTypes.number,\n  tickFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  renderTick: PropTypes.func,\n  legend: PropTypes.node,\n  legendPosition: PropTypes.oneOf(['start', 'middle', 'end']),\n  legendOffset: PropTypes.number\n};\nvar axisPropType = PropTypes.shape(axisPropTypes);\nvar positions = ['top', 'right', 'bottom', 'left'];\n\nvar Axes = function (_PureComponent) {\n  inherits(Axes, _PureComponent);\n\n  function Axes() {\n    classCallCheck(this, Axes);\n    return possibleConstructorReturn(this, _PureComponent.apply(this, arguments));\n  }\n\n  Axes.prototype.render = function render() {\n    var _props = this.props,\n        xScale = _props.xScale,\n        yScale = _props.yScale,\n        width = _props.width,\n        height = _props.height,\n        top = _props.top,\n        right = _props.right,\n        bottom = _props.bottom,\n        left = _props.left,\n        theme = _props.theme,\n        animate = _props.animate,\n        motionStiffness = _props.motionStiffness,\n        motionDamping = _props.motionDamping;\n    var axes = {\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n    return React__default.createElement(React.Fragment, null, positions.map(function (position) {\n      var axis = axes[position];\n      if (!axis) return null;\n      var isXAxis = position === 'top' || position === 'bottom';\n      var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n      return React__default.createElement(Axis$1, _extends({\n        key: position\n      }, axis, {\n        axis: isXAxis ? 'x' : 'y',\n        x: position === 'right' ? width : 0,\n        y: position === 'bottom' ? height : 0,\n        scale: isXAxis ? xScale : yScale,\n        length: isXAxis ? width : height,\n        ticksPosition: ticksPosition,\n        theme: theme,\n        animate: animate,\n        motionDamping: motionDamping,\n        motionStiffness: motionStiffness\n      }));\n    }));\n  };\n\n  return Axes;\n}(React.PureComponent);\n\nAxes.propTypes = _extends({\n  xScale: PropTypes.func.isRequired,\n  yScale: PropTypes.func.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  top: axisPropType,\n  right: axisPropType,\n  bottom: axisPropType,\n  left: axisPropType,\n  theme: PropTypes.shape({\n    axis: core.axisThemePropType.isRequired\n  }).isRequired\n}, core.motionPropTypes);\n\nvar degreesToRadians = function degreesToRadians(degrees) {\n  return degrees * Math.PI / 180;\n};\n\nvar renderAxisToCanvas = function renderAxisToCanvas(ctx, _ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      length = _ref.length,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      _ref$tickSize = _ref.tickSize,\n      tickSize = _ref$tickSize === undefined ? 5 : _ref$tickSize,\n      _ref$tickPadding = _ref.tickPadding,\n      tickPadding = _ref$tickPadding === undefined ? 5 : _ref$tickPadding,\n      _ref$tickRotation = _ref.tickRotation,\n      tickRotation = _ref$tickRotation === undefined ? 0 : _ref$tickRotation,\n      tickValueFormat = _ref.tickValueFormat,\n      theme = _ref.theme;\n\n  var _computeCartesianTick = computeCartesianTicks({\n    axis: axis,\n    scale: scale,\n    ticksPosition: ticksPosition,\n    tickValues: tickValues,\n    tickSize: tickSize,\n    tickPadding: tickPadding,\n    tickRotation: tickRotation,\n    engine: 'canvas'\n  }),\n      ticks = _computeCartesianTick.ticks,\n      textAlign = _computeCartesianTick.textAlign,\n      textBaseline = _computeCartesianTick.textBaseline;\n\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.textAlign = textAlign;\n  ctx.textBaseline = textBaseline;\n  ctx.font = theme.axis.ticks.text.fontSize + 'px sans-serif';\n  ctx.lineWidth = theme.axis.domain.line.strokeWidth;\n  ctx.lineCap = 'square';\n  ctx.strokeStyle = theme.axis.domain.line.stroke;\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length);\n  ctx.stroke();\n  ticks.forEach(function (tick) {\n    ctx.lineWidth = theme.axis.ticks.line.strokeWidth;\n    ctx.lineCap = 'square';\n    ctx.strokeStyle = theme.axis.ticks.line.stroke;\n    ctx.beginPath();\n    ctx.moveTo(tick.x, tick.y);\n    ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY);\n    ctx.stroke();\n    var value = tickValueFormat !== undefined ? tickValueFormat(tick.value) : tick.value;\n    ctx.save();\n    ctx.translate(tick.x + tick.textX, tick.y + tick.textY);\n    ctx.rotate(degreesToRadians(tickRotation));\n    ctx.fillStyle = theme.axis.ticks.text.fill;\n    ctx.fillText(value, 0, 0);\n    ctx.restore();\n  });\n  ctx.restore();\n};\n\nexports.Axes = Axes;\nexports.Axis = Axis$1;\nexports.renderAxisToCanvas = renderAxisToCanvas;\nexports.axisPropTypes = axisPropTypes;\nexports.axisPropType = axisPropType;","map":null,"metadata":{},"sourceType":"script"}