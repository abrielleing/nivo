{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar d3Scale = require('d3-scale');\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar d3TimeFormat = require('d3-time-format');\n\nvar uniq = _interopDefault(require('lodash/uniq'));\n\nvar uniqBy = _interopDefault(require('lodash/uniqBy'));\n\nvar sortBy = _interopDefault(require('lodash/sortBy'));\n\nvar last = _interopDefault(require('lodash/last'));\n\nvar isDate = _interopDefault(require('lodash/isDate'));\n\nvar linearScale = function linearScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$min = _ref.min,\n      min = _ref$min === undefined ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === undefined ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === undefined ? false : _ref$stacked;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = stacked === true ? values.minStacked : values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = stacked === true ? values.maxStacked : values.max;\n  }\n\n  var scale = d3Scale.scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]).domain([minValue, maxValue]);\n  scale.type = 'linear';\n  scale.stacked = stacked;\n  return scale;\n};\n\nvar linearScalePropTypes = {\n  type: PropTypes.oneOf(['linear']).isRequired,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  stacked: PropTypes.bool\n};\n\nvar pointScale = function pointScale(_ref, xy, width, height) {\n  var axis = _ref.axis;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var scale = d3Scale.scalePoint().range([0, size]).domain(values.all);\n  scale.type = 'point';\n  return scale;\n};\n\nvar pointScalePropTypes = {\n  type: PropTypes.oneOf(['point']).isRequired\n};\n\nvar _precisionCutOffsByTy;\n\nvar TIME_PRECISION_MILLISECOND = 'millisecond';\nvar TIME_PRECISION_SECOND = 'second';\nvar TIME_PRECISION_MINUTE = 'minute';\nvar TIME_PRECISION_HOUR = 'hour';\nvar TIME_PRECISION_DAY = 'day';\nvar TIME_PRECISION_MONTH = 'month';\nvar TIME_PRECISION_YEAR = 'year';\nvar timePrecisions = [TIME_PRECISION_MILLISECOND, TIME_PRECISION_SECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_HOUR, TIME_PRECISION_DAY, TIME_PRECISION_MONTH, TIME_PRECISION_YEAR];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = (_precisionCutOffsByTy = {}, _precisionCutOffsByTy[TIME_PRECISION_MILLISECOND] = [], _precisionCutOffsByTy[TIME_PRECISION_SECOND] = precisionCutOffs.slice(0, 1), _precisionCutOffsByTy[TIME_PRECISION_MINUTE] = precisionCutOffs.slice(0, 2), _precisionCutOffsByTy[TIME_PRECISION_HOUR] = precisionCutOffs.slice(0, 3), _precisionCutOffsByTy[TIME_PRECISION_DAY] = precisionCutOffs.slice(0, 4), _precisionCutOffsByTy[TIME_PRECISION_MONTH] = precisionCutOffs.slice(0, 5), _precisionCutOffsByTy[TIME_PRECISION_YEAR] = precisionCutOffs.slice(0, 6), _precisionCutOffsByTy);\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === undefined ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === undefined ? 'millisecond' : _ref$precision;\n  var precisionFn = createPrecisionMethod(precision);\n  if (format === 'native') return function (v) {\n    return precisionFn(v);\n  };\n  var parseTime = d3TimeFormat.timeParse(format);\n  return function (v) {\n    return precisionFn(parseTime(v));\n  };\n};\n\nvar timeScale = function timeScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$format = _ref.format,\n      format = _ref$format === undefined ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === undefined ? TIME_PRECISION_MILLISECOND : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === undefined ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === undefined ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision\n  });\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  } else if (format !== 'native') {\n    minValue = normalize(values.min);\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  } else if (format !== 'native') {\n    maxValue = normalize(values.max);\n  }\n\n  var scale = d3Scale.scaleTime().domain([minValue, maxValue]).range([0, size]);\n  scale.type = 'time';\n  return scale;\n};\n\nvar timeScalePropTypes = {\n  type: PropTypes.oneOf(['time']).isRequired,\n  format: PropTypes.string,\n  precision: PropTypes.oneOf(timePrecisions)\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _extends({}, serie, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _extends({}, d)\n        };\n      })\n    });\n  });\n\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n\n  if (xScaleSpec.stacked === true) {\n    stackX(yScaleSpec.type, xy, series);\n  }\n\n  if (yScaleSpec.stacked === true) {\n    stackY(xScaleSpec.type, xy, series);\n  }\n\n  var xScale = computeScale(_extends({}, xScaleSpec, {\n    axis: 'x'\n  }), xy, width, height);\n  var yScale = computeScale(_extends({}, yScaleSpec, {\n    axis: 'y'\n  }), xy, width, height);\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      d.position = {\n        x: xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : xScale(d.data.x),\n        y: yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : yScale(d.data.y)\n      };\n    });\n  });\n  return _extends({}, xy, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar computeScale = function computeScale(spec, xy, width, height) {\n  if (spec.type === 'linear') return linearScale(spec, xy, width, height);else if (spec.type === 'point') return pointScale(spec, xy, width, height);else if (spec.type === 'time') return timeScale(spec, xy, width, height);\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\n\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        d.data[axis] = d.data[axis] === null ? null : parseFloat(d.data[axis]);\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        d.data[axis] = d.data[axis] === null ? null : parseTime(d.data[axis]);\n      });\n    });\n  }\n\n  var all = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      all.push(d.data[axis]);\n    });\n  });\n  var min = void 0,\n      max = void 0;\n\n  if (scaleSpec.type === 'linear') {\n    all = uniq(all);\n    all = sortBy(all, function (v) {\n      return v;\n    });\n    min = Math.min.apply(Math, all);\n    max = Math.max.apply(Math, all);\n  } else if (scaleSpec.type === 'time') {\n    all = uniqBy(all, function (v) {\n      return v.getTime();\n    });\n    all = all.slice(0).sort(function (a, b) {\n      return b - a;\n    }).reverse();\n    min = all[0];\n    max = last(all);\n  } else {\n    all = uniq(all);\n    min = all[0];\n    max = last(all);\n  }\n\n  return {\n    all: all,\n    min: min,\n    max: max\n  };\n};\n\nvar stackAxis = function stackAxis(axis, otherType, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[axis + 'Stacked'] = stackValue;\n      }\n\n      stack.push(stackValue);\n      all.push(stackValue);\n    });\n  });\n  all = all.filter(function (v) {\n    return v !== null;\n  });\n  xy[axis].minStacked = Math.min.apply(Math, all);\n  xy[axis].maxStacked = Math.max.apply(Math, all);\n};\n\nvar stackX = function stackX(xy, otherType, series) {\n  return stackAxis('x', xy, otherType, series);\n};\n\nvar stackY = function stackY(xy, otherType, series) {\n  return stackAxis('y', xy, otherType, series);\n};\n\nvar computeAxisSlices = function computeAxisSlices(axis, data) {\n  var otherAxis = getOtherAxis(axis);\n  return data[otherAxis].all.map(function (v) {\n    var _slice;\n\n    var slice = (_slice = {\n      id: v\n    }, _slice[otherAxis] = data[otherAxis + 'Scale'](v), _slice.data = [], _slice);\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    data.series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n\n      if (datum !== undefined) {\n        slice.data.push(_extends({}, datum, {\n          serie: serie\n        }));\n      }\n    });\n    slice.data.reverse();\n    return slice;\n  });\n};\n\nvar computeXSlices = function computeXSlices(data) {\n  return computeAxisSlices('x', data);\n};\n\nvar computeYSlices = function computeYSlices(data) {\n  return computeAxisSlices('y', data);\n};\n\nvar scalePropType = PropTypes.oneOfType([PropTypes.shape(linearScalePropTypes), PropTypes.shape(pointScalePropTypes), PropTypes.shape(timeScalePropTypes)]);\nexports.scalePropType = scalePropType;\nexports.getOtherAxis = getOtherAxis;\nexports.compareValues = compareValues;\nexports.compareDateValues = compareDateValues;\nexports.computeXYScalesForSeries = computeXYScalesForSeries;\nexports.computeScale = computeScale;\nexports.generateSeriesXY = generateSeriesXY;\nexports.generateSeriesAxis = generateSeriesAxis;\nexports.stackAxis = stackAxis;\nexports.stackX = stackX;\nexports.stackY = stackY;\nexports.computeAxisSlices = computeAxisSlices;\nexports.computeXSlices = computeXSlices;\nexports.computeYSlices = computeYSlices;\nexports.linearScale = linearScale;\nexports.linearScalePropTypes = linearScalePropTypes;\nexports.pointScale = pointScale;\nexports.pointScalePropTypes = pointScalePropTypes;\nexports.timeScale = timeScale;\nexports.timeScalePropTypes = timeScalePropTypes;","map":null,"metadata":{},"sourceType":"script"}